# Масив (array)
Масивите са първият (и единственият за този курс) и най-важният тип *структури от данни*, който ще разгледаме. Те са основна част от езика, без които много задачи са непосилни.

Масивите представляват *наредени еднотипни* елементи. Тяхната бройка се определя от *размера* на масива. Когато създаваме масив, трябва да определим неговия размер, като го напишем в квадратни скоби `[]` след името на масива.

Пример:
```c
int arr[30];
```
*Забележка!* Когато създаваме масиви, техният размер трябва да бъде ***ясен по време на компилация***. Това означава, че не можем да въведем размера на масива от конзолата.

```c
int arr[30]; // OK
```
```c
const int SIZE_OF_ARRAY = 30;
int arr[SIZE_OF_ARRAY]; // OK*
```
<br/>
<br/>

```c
int size = 30;
int arr[size]; // NOT OK
```
```c
int size;
scanf("%d", &size);

const int SIZE_OF_ARRAY = size;
int arr[SIZE_OF_ARRAY]; // NOT OK
```

## Памет
Когато създаваме масив, в паметта трябва да се заделя точно толкова място, колкото е нужно за да се побере масивът. Тоест, когато направим масив с размер 10, се заделят 10 "клетки" памет. Всяка една от тези клетки играе ролята на променлива.

Масив, тип int, от 3 елемента би изглеждал по следния начин в паметта:
```
[0] [42] [8888]
```
Всяка една от тези клетки съдържа по един int в тях.

Стековите масиви, както и типичните променливи, се намират в т.нар. стекова памет (stack). Освен нея съществуват още две (статична и динамична), но за тях ще говорим по-късно.

## Индексиране
За да достъпим някой елемент от масива, използваме отново квадратните скоби, като в тях поставяме индекса на искания елемент.
```c
printf("%d", arr[0]);  // [0] е първият елемент на масива
printf("%d", arr[10]); // кой елемент е [10]?

for (int i = 0; i < 10; i++)
{
    printf("%d", arr[i]);
}
```

## Инициализиране
Видяхме как се декларира масив по-горе. Ако искаме този масив да има някакви данни в него, трябва да го инициализираме. За това има няколко подхода.

1)  ```c
    int arr[5] = {1, 2, 3, 4, 5};
    ```
2)  ```c
    int arr[] = {1, 2, 3};
    ```
3)  ```c
    int arr[5] = {1}; // останалите елементи стават 0
    ```
4)  ```c
    int arr[5] = {0}; // всички елементи ще са 0
    ```
5)  ```c
    int arr[5];
    arr[0] = 1;
    arr[1] = 4;
    arr[2] = 62;
    arr[3] = 0;
    arr[4] = 9912;
    ```
6)  ```c
    int arr[5];
    for (int i = 0; i < 5; i++)
        scanf("%d", &arr[i]);
    ```

*Важно!* При масивите, името на променливата не представлява целия масив, а само неговото начало. Следователно не можем да подадем масива на printf и да очакваме че това ще го принтира в някакъв формат. Когато подадем масив на потока за извеждане, на екрана ще получим адреса на първия му елемент. За адреси ще говорим по-късно. 

# Символен низ (string)
Символния низ е масив съставен от символен тип. Най-често това е char. 
```c
char str[100];
```
Те са по-особени в това, че накрая на всеки низ трябва да има поставен терминиращ символ (ASCII код 0) `\0`, който символизира края на низа.

```c
char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

Низове можем и да принтираме с помощта на форматиращия спецификатор `%s`

```c
char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};

printf("%s world", str);
```
```
Hello world
```
За да избегнем това писане на `'\0'`, можем да напишем низа, който искаме да запазим, в двойни кавички `""`, които го поставят автоматично в края.

```c
char str[6] = "Hello"; // 5 символа + '\0'
printf("%s", str);
```
Позволен е и следният вариант:
```c
char str[] = "Hello, world!";
printf("%s", str);
```

Когато искаме да въвеждаме някакъв низ, трябва да сме сигурни, че ще заделим достатъчно буферно пространство, за да не прескочим границите на масива.

```c
char buffer[1024];

scanf("%s", buffer);
```

# sizeof
`sizeof` е оператор, който ни показва колко памет(в байтове) заема дадена променлива от съответен тип. `sizeof` връща като резултат тип `size_t`. 

Може да се използва по 2 начина:
```c
int a = 10;

printf("%zu", sizeof(a));
//или
printf("%zu", sizeof a);
```
Въвежда се нов форматиращ спецификатор - `%zu`

```
z - типът е size_t
u - да бъде принтиран като цяло unsigned число
```

Освен това може да се провери директно за някой тип, в който случай можем да използваме само:
```c
printf("%zu", sizeof(int));
```
*Когато използваме `sizeof` за **тип**, вместо **променлива**, вторият вариант (напр. `sizeof int`) **не е** валиден.*

```c
printf("char:\t\t%zu bytes\n", sizeof(char));
printf("short:\t\t%zu bytes\n", sizeof(short));
printf("int:\t\t%zu bytes\n", sizeof(int));
printf("long:\t\t%zu bytes\n", sizeof(long));
printf("float:\t\t%zu bytes\n", sizeof(float));
printf("double:\t\t%zu bytes\n", sizeof(double));
printf("long double:\t%zu bytes\n", sizeof(long double));
```

```c
char:    		1 bytes
short:    		2 bytes
int:    		4 bytes
long:    		8 bytes
float:    		4 bytes
double:         8 bytes
long double:    16 bytes
```

Ако използваме `sizeof` върху масив, тогава ще получим неговия размер (отново, в байтове)

```c
double arr[100];

printf("%zu", sizeof(arr));
```
```
800
```